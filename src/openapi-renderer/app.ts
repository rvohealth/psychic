import * as fs from 'fs/promises'
import { groupBy } from 'lodash-es'
import EnvInternal from '../helpers/EnvInternal.js'
import openapiJsonPath from '../helpers/openapiJsonPath.js'
import PsychicApplication from '../psychic-application/index.js'
import { HttpMethod, HttpMethods } from '../router/types.js'
import PsychicServer from '../server/index.js'
import { DEFAULT_OPENAPI_COMPONENT_RESPONSES, DEFAULT_OPENAPI_COMPONENT_SCHEMAS } from './defaults.js'
import { OpenapiEndpointResponsePath, OpenapiParameterResponse, OpenapiSchema } from './endpoint.js'

export default class OpenapiAppRenderer {
  /**
   * @internal
   *
   * reads the lates openapi builds using buildOpenapiObject, and syncs
   * the contents to the openapi.json file at the project root.
   */
  public static async sync() {
    const openapiContents = await OpenapiAppRenderer.toObject()

    const psychicApp = PsychicApplication.getOrFail()
    const asyncWriteOpenapiFile = async (key: string) => {
      const jsonPath = openapiJsonPath(key)
      await fs.writeFile(jsonPath, JSON.stringify(openapiContents[key], null, 2), {
        flag: 'w+',
      })
    }

    await Promise.all(Object.keys(psychicApp.openapi).map(key => asyncWriteOpenapiFile(key)))
  }

  /**
   * @internal
   *
   * builds a new typescript object which contains the combined
   * payloads of all `@Openapi` decorator calls used throughout
   * the controller layer.
   */
  public static async toObject(): Promise<Record<string, OpenapiSchema>> {
    const psychicApp = PsychicApplication.getOrFail()

    const convertToObjectAndStoreInOutput = async (output: Record<string, OpenapiSchema>, key: string) => {
      output[key] = await this._toObject(key)
    }

    const output: Record<string, OpenapiSchema> = {}
    await Promise.all(
      Object.keys(psychicApp.openapi).map(key => convertToObjectAndStoreInOutput(output, key)),
    )

    return output
  }

  public static async _toObject(openapiName: string): Promise<OpenapiSchema> {
    const processedSchemas: Record<string, boolean> = {}
    const psychicApp = PsychicApplication.getOrFail()
    const controllers = psychicApp.controllers

    const server = new PsychicServer()
    await server.boot()
    const routes = await server.routes()

    const openapiConfig = psychicApp.openapi?.[openapiName]

    const finalOutput: OpenapiSchema = {
      openapi: '3.1.0',
      info: {
        version: openapiConfig?.info?.version || 'unknown version',
        title: openapiConfig?.info?.title || 'unknown title',
        description: openapiConfig?.info?.description || 'The autogenerated openapi spec for your app',
      },
      paths: {},
      components: {
        ...(psychicApp.openapi?.[openapiName]?.defaults?.components || {}),
        schemas: {
          ...DEFAULT_OPENAPI_COMPONENT_SCHEMAS,
          ...((psychicApp.openapi?.[openapiName]?.defaults?.components?.schemas ||
            {}) as typeof DEFAULT_OPENAPI_COMPONENT_SCHEMAS),
        },
        responses: {
          ...DEFAULT_OPENAPI_COMPONENT_RESPONSES,
          ...(psychicApp.openapi?.[openapiName]?.defaults?.components?.responses || {}),
        },
      },
    }

    if (psychicApp.openapi?.[openapiName]?.servers) {
      finalOutput.servers = psychicApp.openapi?.[openapiName]?.servers
    }

    if (psychicApp.openapi?.[openapiName]?.defaults?.securitySchemes) {
      finalOutput.components = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
        securitySchemes: psychicApp.openapi?.[openapiName].defaults.securitySchemes as any,
        ...finalOutput.components,
      }
    }

    if (psychicApp.openapi?.[openapiName]?.defaults?.security) {
      finalOutput.security = psychicApp.openapi?.[openapiName].defaults.security
    }

    for (const [controllerName, controller] of Object.entries(controllers).filter(([, controller]) =>
      controller.openapiNames.includes(openapiName),
    )) {
      for (const key of Object.keys(controller.openapi || {})) {
        if (EnvInternal.isDebug) console.log(`Processing OpenAPI key ${key} for controller ${controllerName}`)

        const renderer = controller.openapi[key]

        finalOutput.components.schemas = {
          ...finalOutput.components.schemas,
          ...renderer.toSchemaObject(openapiName, processedSchemas),
        }

        const endpointPayload = renderer.toPathObject(openapiName, processedSchemas, routes)
        const path = Object.keys(endpointPayload)[0]

        const method = (Object.keys(endpointPayload[path]) as HttpMethod[]).find(key =>
          HttpMethods.includes(key),
        )!

        if (!finalOutput.paths[path]) {
          finalOutput.paths[path] = { parameters: [] } as unknown as OpenapiEndpointResponsePath
        }

        const pathObj = finalOutput.paths[path]
        const otherPathObj = endpointPayload[path]

        pathObj[method] = otherPathObj[method]

        pathObj.parameters = this.combineParameters([
          ...pathObj.parameters,
          ...endpointPayload[path].parameters,
        ])
      }
    }

    return this.sortedSchemaPayload(finalOutput)
  }

  private static combineParameters(parameters: OpenapiParameterResponse[]) {
    const groupedParams = groupBy(parameters, 'name')

    const result = Object.keys(groupedParams).map(paramName => {
      const identicalParams = groupedParams[paramName]
      return identicalParams.reduce((compositeParam, param) => {
        compositeParam.description ||= param.description

        if (compositeParam.allowEmptyValue !== undefined)
          compositeParam.allowEmptyValue = param.allowEmptyValue

        if (compositeParam.allowReserved !== undefined) compositeParam.allowReserved = param.allowReserved

        if (compositeParam.required !== undefined) compositeParam.required = param.required

        return compositeParam
      }, identicalParams[0])
    })

    return result
  }

  private static sortedSchemaPayload(schema: OpenapiSchema) {
    const sortedPaths = Object.keys(schema.paths).sort()
    const sortedSchemas = Object.keys(schema.components.schemas).sort()

    const sortedSchema: typeof schema = { ...schema }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    sortedSchema.paths = sortedPaths.reduce((agg, path) => {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      agg[path] = schema.paths[path]

      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      return agg
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }, {} as any)

    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    sortedSchema.components.schemas = sortedSchemas.reduce((agg, key) => {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      agg[key] = schema.components.schemas[key]

      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      return agg
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }, {} as any)

    return sortedSchema
  }
}
