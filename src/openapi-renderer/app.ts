import { OpenapiSchemaBody } from '@rvoh/dream/openapi'
import { CliFileWriter } from '@rvoh/dream/system'
import { compact, groupBy, sortObjectByKey } from '@rvoh/dream/utils'
import { debuglog } from 'node:util'
import UnexpectedUndefined from '../error/UnexpectedUndefined.js'
import openapiJsonPath from '../helpers/openapiJsonPath.js'
import PsychicApp from '../psychic-app/index.js'
import { RouteConfig } from '../router/route-manager.js'
import { HttpMethod, HttpMethods } from '../router/types.js'
import { DEFAULT_OPENAPI_COMPONENT_RESPONSES, DEFAULT_OPENAPI_COMPONENT_SCHEMAS } from './defaults.js'
import {
  MissingControllerActionPairingInRoutes,
  OpenapiEndpointResponsePath,
  OpenapiParameterResponse,
  OpenapiRenderOpts,
  OpenapiSchema,
} from './endpoint.js'
import suppressResponseEnumsConfig from './helpers/suppressResponseEnumsConfig.js'

const debugEnabled = debuglog('psychic').enabled

export default class OpenapiAppRenderer {
  /**
   * @internal
   *
   * reads the lates openapi builds using buildOpenapiObject, and syncs
   * the contents to the openapi.json file at the project root.
   */
  public static async sync() {
    const openapiContents = OpenapiAppRenderer.toObject()

    const psychicApp = PsychicApp.getOrFail()
    const asyncWriteOpenapiFile = async (openapiName: string) => {
      const jsonPath = openapiJsonPath(openapiName)
      await CliFileWriter.write(jsonPath, JSON.stringify(openapiContents[openapiName], null, 2), {
        flag: 'w+',
      })
    }

    await Promise.all(Object.keys(psychicApp.openapi).map(key => asyncWriteOpenapiFile(key)))
  }

  /**
   * @internal
   *
   * builds a new typescript object which contains the combined
   * payloads of all `@Openapi` decorator calls used throughout
   * the controller layer.
   */
  public static toObject(): Record<string, OpenapiSchema> {
    const psychicApp = PsychicApp.getOrFail()
    const output: Record<string, OpenapiSchema> = {}

    const routes = psychicApp.routesCache

    Object.keys(psychicApp.openapi).forEach(key => {
      output[key] = this._toObject(routes, key)
    })

    return output
  }

  public static _toObject(
    routes: RouteConfig[],
    openapiName: string,
    { bypassMissingRoutes = false }: { bypassMissingRoutes?: boolean } = {},
  ): OpenapiSchema {
    const renderOpts: OpenapiRenderOpts = {
      casing: 'camel',
      suppressResponseEnums: suppressResponseEnumsConfig(openapiName),
    }

    const alreadyExtractedDescendantSerializers: Record<string, boolean> = {}
    const renderedSchemasOpenapi: Record<string, OpenapiSchemaBody> = {}
    const psychicApp = PsychicApp.getOrFail()
    const controllers = psychicApp.controllers

    const openapiConfig = psychicApp.openapi?.[openapiName]

    const finalOutput: OpenapiSchema = {
      openapi: '3.1.0',
      info: {
        version: openapiConfig?.info?.version || 'unknown version',
        title: openapiConfig?.info?.title || 'unknown title',
        description: openapiConfig?.info?.description || 'The autogenerated openapi spec for your app',
      },
      paths: {},
      components: {
        ...(psychicApp.openapi?.[openapiName]?.defaults?.components || {}),
        schemas: {
          ...DEFAULT_OPENAPI_COMPONENT_SCHEMAS,
          ...((psychicApp.openapi?.[openapiName]?.defaults?.components?.schemas ||
            {}) as typeof DEFAULT_OPENAPI_COMPONENT_SCHEMAS),
        },
        responses: {
          ...DEFAULT_OPENAPI_COMPONENT_RESPONSES,
          ...(psychicApp.openapi?.[openapiName]?.defaults?.components?.responses || {}),
        },
      },
    }

    if (psychicApp.openapi?.[openapiName]?.servers) {
      finalOutput.servers = psychicApp.openapi?.[openapiName]?.servers
    }

    if (psychicApp.openapi?.[openapiName]?.defaults?.securitySchemes) {
      finalOutput.components = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment
        securitySchemes: psychicApp.openapi?.[openapiName].defaults.securitySchemes as any,
        ...finalOutput.components,
      }
    }

    if (psychicApp.openapi?.[openapiName]?.defaults?.security) {
      finalOutput.security = psychicApp.openapi?.[openapiName].defaults.security
    }

    for (const [controllerName, controller] of Object.entries(controllers).filter(([, controller]) =>
      controller.openapiNames.includes(openapiName),
    )) {
      for (const key of Object.keys(controller.openapi || {})) {
        if (debugEnabled) PsychicApp.log(`Processing OpenAPI key ${key} for controller ${controllerName}`)

        const renderer = controller.openapi[key]
        if (renderer === undefined) throw new UnexpectedUndefined()

        try {
          const endpointPayloadAndReferencedSerializers = renderer.toPathObject(routes, {
            openapiName,
            renderOpts,
          })
          const serializersAppearingInHandWrittenOpenapi =
            endpointPayloadAndReferencedSerializers.referencedSerializers
          const endpointPayload = endpointPayloadAndReferencedSerializers.openapi

          if (endpointPayload === undefined) throw new UnexpectedUndefined()
          const path = Object.keys(endpointPayload)[0]
          if (path === undefined) throw new UnexpectedUndefined()
          const endpointPayloadPath = endpointPayload[path]
          if (endpointPayloadPath === undefined) throw new UnexpectedUndefined()

          const method = (Object.keys(endpointPayloadPath) as HttpMethod[]).find(key =>
            HttpMethods.includes(key),
          )!

          if (!finalOutput.paths[path]) {
            finalOutput.paths[path] = { parameters: [] } as unknown as OpenapiEndpointResponsePath
          }

          const finalPathObject = finalOutput.paths[path]
          finalPathObject[method] = endpointPayloadPath[method]

          finalPathObject.parameters = this.combineParameters([
            ...finalPathObject.parameters,
            ...endpointPayloadPath.parameters,
          ])

          renderer.toSchemaObject({
            openapiName,
            renderOpts,
            renderedSchemasOpenapi,
            alreadyExtractedDescendantSerializers,
            serializersAppearingInHandWrittenOpenapi,
          })

          finalOutput.components.schemas = {
            ...finalOutput.components.schemas,
            ...renderedSchemasOpenapi,
          }
        } catch (err) {
          if (err instanceof MissingControllerActionPairingInRoutes && bypassMissingRoutes) {
            continue
          }
          throw err
        }
      }
    }

    const components = finalOutput.components
    const paths = finalOutput.paths ?? {}
    const schemas = components.schemas ?? {}

    finalOutput.paths = sortObjectByKey(paths)
    components.schemas = sortObjectByKey(schemas)

    return finalOutput
  }

  private static combineParameters(parameters: OpenapiParameterResponse[]): OpenapiParameterResponse[] {
    const groupedParams = groupBy(parameters, obj => obj.name)

    return compact(
      Object.keys(groupedParams).map(paramName => {
        const identicalParams = groupedParams[paramName] || []

        return identicalParams.reduce((compositeParam, param) => {
          if (compositeParam === undefined) throw new UnexpectedUndefined()
          compositeParam.description ||= param.description

          if (param.allowEmptyValue !== undefined) compositeParam.allowEmptyValue = param.allowEmptyValue
          if (param.allowReserved !== undefined) compositeParam.allowReserved = param.allowReserved
          if (param.required !== undefined) compositeParam.required = param.required

          return compositeParam
        }, identicalParams[0])
      }),
    )
  }
}
